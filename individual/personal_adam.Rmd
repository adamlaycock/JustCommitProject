---
title: "Adam Personal Investigation"
author: "AdamLaycock"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load-lib, message = FALSE}
library(tidyverse)
library(janitor)
library(workflows)
library(parsnip)
library(tidyclust)
library(tidymodels)
```

```{r load-data}
details = read_csv('../Data/details_combined.csv')
fatalities = read_csv('../Data/fatalities_combined.csv')
```

```{r Data Cleaning}
# Merge and convert formats of begin-date variables
details <- details %>%
  # Combine date elements
  unite("BEGIN_DATE", BEGIN_YEARMONTH, BEGIN_DAY, sep = "") %>% 
  mutate(
    # Convert date to a character for union with time
    BEGIN_DATE = as.character(BEGIN_DATE),
    # Add leading zero if the time is 3 digits
    BEGIN_TIME = case_when(
      BEGIN_TIME < 1000 ~ sprintf("%04d", BEGIN_TIME),
      TRUE ~ as.character(BEGIN_TIME)
    )
  ) %>%
  # Unite date and time into one string
  unite("BEGIN_DT", BEGIN_DATE, BEGIN_TIME, sep = " ") %>%
  mutate(
    # Convert to a datetime
    BEGIN_DT = ymd_hm(BEGIN_DT)
  )

# Merge and convert formats of end-date variables
details <- details %>%
  # Combine date elements
  unite("END_DATE", END_YEARMONTH, END_DAY, sep = "") %>% 
  mutate(
    # Convert date to a character for union with time
    END_DATE = as.character(END_DATE),
    # Add leading zero if the time is 3 digits
    END_TIME = case_when(
      END_TIME < 1000 ~ sprintf("%04d", END_TIME),
      TRUE ~ as.character(END_TIME)
    )
  ) %>%
  # Unite date and time into one string
  unite("END_DT", END_DATE, END_TIME, sep = " ") %>%
  mutate(
    # Convert to a datetime
    END_DT = ymd_hm(END_DT)
  )

# Remove unnecessary columns
details <- details %>%
  select(-c(YEAR, MONTH_NAME, BEGIN_DATE_TIME, END_DATE_TIME))

# Rename incorrect column names
details <- details %>%
  rename(REGION = STATE,
         REGION_FIPS = STATE_FIPS)

# Create duration variable 
details <- details %>% 
  mutate(
    duration = END_DT - BEGIN_DT
  ) %>% 
    mutate(
      duration = as.numeric(duration) / 60
    )

# Change cost suffixes
details <- details %>% 
  mutate(
    DAMAGE_PROPERTY = as.numeric(gsub("K", "e+03", gsub("M", "e+06", DAMAGE_PROPERTY))),
    DAMAGE_CROPS = as.numeric(gsub("K", "e+03", gsub("M", "e+06", DAMAGE_CROPS)))
  )

# Create a total damage column using crops and property
details <- details %>%
  mutate(
    DAMAGE_TOTAL = DAMAGE_PROPERTY + DAMAGE_CROPS
  )

# Remove all records pertaining to an incomplete year
details <- details %>% 
  filter(
    !year(BEGIN_DT) == '2024'
  )

# Use janitor to convert variable names to snakecase
details <- details %>% 
  clean_names()

# Tidy the fatalities DataFrame
fatalities <- fatalities %>% 
  select(
    -FAT_TIME, -FATALITY_DATE, -EVENT_YEARMONTH
  ) %>% 
    mutate(
      YMD = ymd(paste(FAT_YEARMONTH, FAT_DAY))
    ) %>% 
      select(
        -FAT_DAY, -FAT_YEARMONTH
      )

# Remove 2024 records
fatalities <- fatalities %>%
  filter(
    !year(YMD) == '2024'
  )

# Use janitor to convert variables to snakecase
fatalities <- fatalities %>% 
  clean_names()
```

```{r Combined Metrics by Event ID}
# Create combined metrics by combining direct and indirect
details <- details %>% 
  mutate(
    attributed_deaths = deaths_direct + deaths_indirect,
    attributed_injuries = injuries_direct + injuries_indirect,
    attributed_casualities = attributed_deaths + attributed_injuries
  )
```

```{r Feature Selection & Engineering}
# Select only relevant data and remove rows with NA
model_data <- details %>% 
  select(
    event_id, attributed_casualities, damage_total, event_type
  ) %>% 
    filter(
      !is.na(damage_total) & !is.na(attributed_casualities)
    )

# Z-Score normalise the data
model_data_scaled <- model_data %>%
  mutate(
    damage_total = as.vector(scale(damage_total)),
    attributed_casualities = as.vector(scale(attributed_casualities))
  )
```

```{r Elbow Plot for Optimisation, eval=FALSE}
# Initialise empty lists
k_list = list()
sse_list = list()

# Loop through 1-30 clusters and store total sum of squared error
for (k in 1:30) {
  kmeans_spec <- k_means(num_clusters = k)
  
  kmeans_fit <- kmeans_spec %>%
    fit(~ damage_total + attributed_casualities, data = model_data_scaled)
  
  kmeans_result <- kmeans_fit$fit
  sse <- kmeans_result$tot.withinss
  
  k_list <- c(k_list, k)
  sse_list <- c(sse_list, sse)
  
  print(paste("Number of clusters:", k))
  print(paste("Total SSE:", sse))
}

# Convert lists to a DataFrame
elbow_data <- data.frame(unlist(k_list), unlist(sse_list))
names(elbow_data) = c("k","total_sse")


# Create elboe plot using clustering data
elbow_data %>% 
  ggplot(
    mapping=aes(
      x=k,
      y=total_sse
    )
  ) + 
  geom_line() +
  geom_point() + 
  scale_x_continuous(breaks = seq(1, 30, by = 1)) +
  labs(
    title='Total SSE by Number of Clusters', 
    x='Number of Clusters (k)',
    y='Total SSE'
  ) +
  theme_minimal()
```

```{r Optimised Model}
kmeans_spec <- k_means(num_clusters = 3)

kmeans_fit <- kmeans_spec %>%
  fit(~ damage_total + attributed_casualities, data = model_data_scaled)

model_data_scaled <- kmeans_fit %>% 
  augment(model_data_scaled)
```

```{r Scatter Plot of Scaled Data by Cluster}
model_data_scaled %>% 
  ggplot(
    mapping=aes(
      x=damage_total,
      y=attributed_casualities,
      colour=.pred_cluster
    )
  ) +
  geom_jitter() +
  labs(
    x='Scaled Total Damage',
    y='Scaled Attributed Deaths',
    title='K-Means Clustering of Casualties & Damages',
    colour='Cluster'
  ) +
  theme_minimal()
```

```{r Cluster Frequency Table}
model_data_scaled %>% 
  group_by(
    .pred_cluster
  ) %>% 
    summarise(
      total = n()
    )
```
